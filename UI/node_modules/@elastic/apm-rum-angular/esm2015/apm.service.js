import { Inject, Injectable } from '@angular/core';
import { afterFrame } from '@elastic/apm-rum-core';
import { APM } from './apm.module';
import * as i0 from "@angular/core";
import * as i1 from "@angular/router";
import * as i2 from "@elastic/apm-rum";
export class ApmService {
    constructor(apm, router, ngZone) {
        this.apm = apm;
        this.router = router;
        this.ngZone = ngZone;
    }
    init(config) {
        const apmInstance = this.ngZone.runOutsideAngular(() => this.apm.init(config));
        if (!apmInstance.isActive()) {
            return apmInstance;
        }
        /**
         * Start listening to route change once we
         * intiailize to set the correct transaction names
         */
        this.observe();
        return apmInstance;
    }
    observe() {
        let transaction;
        this.router.events.subscribe(event => {
            const eventName = event.toString();
            if (eventName.indexOf('NavigationStart') >= 0) {
                const name = event.url;
                transaction = this.apm.startTransaction(name, 'route-change', {
                    managed: true,
                    canReuse: true
                });
            }
            else if (eventName.indexOf('NavigationError') >= 0) {
                transaction && transaction.detectFinish();
            }
            else if (eventName.indexOf('NavigationEnd') >= 0) {
                if (!transaction) {
                    return;
                }
                /**
                 * The below logic must be placed in NavigationEnd since
                 * the we depend on the current route state to get the path
                 *
                 * Even If there are any redirects, the router state path
                 * will be matched with the correct url on navigation end
                 *
                 * Traverse the activated route tree to figure out the nested
                 * route path
                 */
                const route = this.router.routerState.root.firstChild;
                if (route) {
                    let child = route;
                    let path = '/' + child.routeConfig.path;
                    while (child) {
                        child = child.firstChild;
                        if (child && child.routeConfig) {
                            const currentPath = child.routeConfig.path;
                            /**
                             * Ignore empty path's in the route config
                             */
                            if (currentPath) {
                                path += '/' + currentPath;
                            }
                        }
                    }
                    transaction.name = path;
                }
                afterFrame(() => transaction.detectFinish());
            }
        });
    }
}
ApmService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: ApmService, deps: [{ token: APM }, { token: i1.Router }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });
ApmService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: ApmService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: ApmService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i2.ApmBase, decorators: [{
                    type: Inject,
                    args: [APM]
                }] }, { type: i1.Router }, { type: i0.NgZone }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBtLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvYXBtLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBMkJBLE9BQU8sRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFVLE1BQU0sZUFBZSxDQUFBO0FBQzFELE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQTtBQUdsRCxPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sY0FBYyxDQUFBOzs7O0FBS2xDLE1BQU0sT0FBTyxVQUFVO0lBQ3JCLFlBQ3NCLEdBQVksRUFDeEIsTUFBYyxFQUNMLE1BQWM7UUFGWCxRQUFHLEdBQUgsR0FBRyxDQUFTO1FBQ3hCLFdBQU0sR0FBTixNQUFNLENBQVE7UUFDTCxXQUFNLEdBQU4sTUFBTSxDQUFRO0lBQzlCLENBQUM7SUFFSixJQUFJLENBQUMsTUFBMEI7UUFDN0IsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLEVBQUUsQ0FDckQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQ3RCLENBQUE7UUFFRCxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsRUFBRSxFQUFFO1lBQzNCLE9BQU8sV0FBVyxDQUFBO1NBQ25CO1FBRUQ7OztXQUdHO1FBQ0gsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFBO1FBQ2QsT0FBTyxXQUFXLENBQUE7SUFDcEIsQ0FBQztJQUVELE9BQU87UUFDTCxJQUFJLFdBQVcsQ0FBQTtRQUNmLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUNuQyxNQUFNLFNBQVMsR0FBRyxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUE7WUFDbEMsSUFBSSxTQUFTLENBQUMsT0FBTyxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxFQUFFO2dCQUM3QyxNQUFNLElBQUksR0FBSSxLQUF5QixDQUFDLEdBQUcsQ0FBQTtnQkFDM0MsV0FBVyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLGNBQWMsRUFBRTtvQkFDNUQsT0FBTyxFQUFFLElBQUk7b0JBQ2IsUUFBUSxFQUFFLElBQUk7aUJBQ2YsQ0FBQyxDQUFBO2FBQ0g7aUJBQU0sSUFBSSxTQUFTLENBQUMsT0FBTyxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxFQUFFO2dCQUNwRCxXQUFXLElBQUksV0FBVyxDQUFDLFlBQVksRUFBRSxDQUFBO2FBQzFDO2lCQUFNLElBQUksU0FBUyxDQUFDLE9BQU8sQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLEVBQUU7Z0JBQ2xELElBQUksQ0FBQyxXQUFXLEVBQUU7b0JBQ2hCLE9BQU07aUJBQ1A7Z0JBRUQ7Ozs7Ozs7OzttQkFTRztnQkFDSCxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFBO2dCQUVyRCxJQUFJLEtBQUssRUFBRTtvQkFDVCxJQUFJLEtBQUssR0FBRyxLQUFLLENBQUE7b0JBQ2pCLElBQUksSUFBSSxHQUFHLEdBQUcsR0FBRyxLQUFLLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQTtvQkFDdkMsT0FBTyxLQUFLLEVBQUU7d0JBQ1osS0FBSyxHQUFHLEtBQUssQ0FBQyxVQUFVLENBQUE7d0JBQ3hCLElBQUksS0FBSyxJQUFJLEtBQUssQ0FBQyxXQUFXLEVBQUU7NEJBQzlCLE1BQU0sV0FBVyxHQUFHLEtBQUssQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFBOzRCQUMxQzs7K0JBRUc7NEJBQ0gsSUFBSSxXQUFXLEVBQUU7Z0NBQ2YsSUFBSSxJQUFJLEdBQUcsR0FBRyxXQUFXLENBQUE7NkJBQzFCO3lCQUNGO3FCQUNGO29CQUNELFdBQVcsQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFBO2lCQUN4QjtnQkFFRCxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsV0FBVyxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUE7YUFDN0M7UUFDSCxDQUFDLENBQUMsQ0FBQTtJQUNKLENBQUM7O3VHQTFFVSxVQUFVLGtCQUVYLEdBQUc7MkdBRkYsVUFBVSxjQUZULE1BQU07MkZBRVAsVUFBVTtrQkFIdEIsVUFBVTttQkFBQztvQkFDVixVQUFVLEVBQUUsTUFBTTtpQkFDbkI7OzBCQUdJLE1BQU07MkJBQUMsR0FBRyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTUlUIExpY2Vuc2VcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTctcHJlc2VudCwgRWxhc3RpY3NlYXJjaCBCVlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKlxuICovXG5cbmltcG9ydCB7IFJvdXRlciB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcidcbmltcG9ydCB7IE5hdmlnYXRpb25TdGFydCB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcidcbmltcG9ydCB7IEluamVjdCwgSW5qZWN0YWJsZSwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSdcbmltcG9ydCB7IGFmdGVyRnJhbWUgfSBmcm9tICdAZWxhc3RpYy9hcG0tcnVtLWNvcmUnXG5pbXBvcnQgeyBBcG1CYXNlIH0gZnJvbSAnQGVsYXN0aWMvYXBtLXJ1bSdcbmltcG9ydCB7IEFnZW50Q29uZmlnT3B0aW9ucyB9IGZyb20gJ0BlbGFzdGljL2FwbS1ydW0nXG5pbXBvcnQgeyBBUE0gfSBmcm9tICcuL2FwbS5tb2R1bGUnXG5cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIEFwbVNlcnZpY2Uge1xuICBjb25zdHJ1Y3RvcihcbiAgICBASW5qZWN0KEFQTSkgcHVibGljIGFwbTogQXBtQmFzZSxcbiAgICBwcml2YXRlIHJvdXRlcjogUm91dGVyLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgbmdab25lOiBOZ1pvbmVcbiAgKSB7fVxuXG4gIGluaXQoY29uZmlnOiBBZ2VudENvbmZpZ09wdGlvbnMpIHtcbiAgICBjb25zdCBhcG1JbnN0YW5jZSA9IHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+XG4gICAgICB0aGlzLmFwbS5pbml0KGNvbmZpZylcbiAgICApXG5cbiAgICBpZiAoIWFwbUluc3RhbmNlLmlzQWN0aXZlKCkpIHtcbiAgICAgIHJldHVybiBhcG1JbnN0YW5jZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IGxpc3RlbmluZyB0byByb3V0ZSBjaGFuZ2Ugb25jZSB3ZVxuICAgICAqIGludGlhaWxpemUgdG8gc2V0IHRoZSBjb3JyZWN0IHRyYW5zYWN0aW9uIG5hbWVzXG4gICAgICovXG4gICAgdGhpcy5vYnNlcnZlKClcbiAgICByZXR1cm4gYXBtSW5zdGFuY2VcbiAgfVxuXG4gIG9ic2VydmUoKSB7XG4gICAgbGV0IHRyYW5zYWN0aW9uXG4gICAgdGhpcy5yb3V0ZXIuZXZlbnRzLnN1YnNjcmliZShldmVudCA9PiB7XG4gICAgICBjb25zdCBldmVudE5hbWUgPSBldmVudC50b1N0cmluZygpXG4gICAgICBpZiAoZXZlbnROYW1lLmluZGV4T2YoJ05hdmlnYXRpb25TdGFydCcpID49IDApIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IChldmVudCBhcyBOYXZpZ2F0aW9uU3RhcnQpLnVybFxuICAgICAgICB0cmFuc2FjdGlvbiA9IHRoaXMuYXBtLnN0YXJ0VHJhbnNhY3Rpb24obmFtZSwgJ3JvdXRlLWNoYW5nZScsIHtcbiAgICAgICAgICBtYW5hZ2VkOiB0cnVlLFxuICAgICAgICAgIGNhblJldXNlOiB0cnVlXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKGV2ZW50TmFtZS5pbmRleE9mKCdOYXZpZ2F0aW9uRXJyb3InKSA+PSAwKSB7XG4gICAgICAgIHRyYW5zYWN0aW9uICYmIHRyYW5zYWN0aW9uLmRldGVjdEZpbmlzaCgpXG4gICAgICB9IGVsc2UgaWYgKGV2ZW50TmFtZS5pbmRleE9mKCdOYXZpZ2F0aW9uRW5kJykgPj0gMCkge1xuICAgICAgICBpZiAoIXRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGJlbG93IGxvZ2ljIG11c3QgYmUgcGxhY2VkIGluIE5hdmlnYXRpb25FbmQgc2luY2VcbiAgICAgICAgICogdGhlIHdlIGRlcGVuZCBvbiB0aGUgY3VycmVudCByb3V0ZSBzdGF0ZSB0byBnZXQgdGhlIHBhdGhcbiAgICAgICAgICpcbiAgICAgICAgICogRXZlbiBJZiB0aGVyZSBhcmUgYW55IHJlZGlyZWN0cywgdGhlIHJvdXRlciBzdGF0ZSBwYXRoXG4gICAgICAgICAqIHdpbGwgYmUgbWF0Y2hlZCB3aXRoIHRoZSBjb3JyZWN0IHVybCBvbiBuYXZpZ2F0aW9uIGVuZFxuICAgICAgICAgKlxuICAgICAgICAgKiBUcmF2ZXJzZSB0aGUgYWN0aXZhdGVkIHJvdXRlIHRyZWUgdG8gZmlndXJlIG91dCB0aGUgbmVzdGVkXG4gICAgICAgICAqIHJvdXRlIHBhdGhcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHJvdXRlID0gdGhpcy5yb3V0ZXIucm91dGVyU3RhdGUucm9vdC5maXJzdENoaWxkXG5cbiAgICAgICAgaWYgKHJvdXRlKSB7XG4gICAgICAgICAgbGV0IGNoaWxkID0gcm91dGVcbiAgICAgICAgICBsZXQgcGF0aCA9ICcvJyArIGNoaWxkLnJvdXRlQ29uZmlnLnBhdGhcbiAgICAgICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgICAgIGNoaWxkID0gY2hpbGQuZmlyc3RDaGlsZFxuICAgICAgICAgICAgaWYgKGNoaWxkICYmIGNoaWxkLnJvdXRlQ29uZmlnKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQYXRoID0gY2hpbGQucm91dGVDb25maWcucGF0aFxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogSWdub3JlIGVtcHR5IHBhdGgncyBpbiB0aGUgcm91dGUgY29uZmlnXG4gICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICBpZiAoY3VycmVudFBhdGgpIHtcbiAgICAgICAgICAgICAgICBwYXRoICs9ICcvJyArIGN1cnJlbnRQYXRoXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdHJhbnNhY3Rpb24ubmFtZSA9IHBhdGhcbiAgICAgICAgfVxuXG4gICAgICAgIGFmdGVyRnJhbWUoKCkgPT4gdHJhbnNhY3Rpb24uZGV0ZWN0RmluaXNoKCkpXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuIl19